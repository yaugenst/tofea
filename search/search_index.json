{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TOFEA Documentation","text":"<p>Welcome to the TOFEA documentation. This site is generated with MkDocs and contains API reference material extracted from the source code. The examples in the repository show how to solve simple heat conduction and compliance problems using <code>autograd</code> for automatic differentiation.</p> <p>To build the documentation locally use:</p> <pre><code>pip install -e .[docs]\nmkdocs serve\n</code></pre>"},{"location":"reference/","title":"API Reference","text":"<p>This section contains the automatically generated API reference. Each module is documented with <code>mkdocstrings</code> and the examples included in the docstrings are executed as doctests during continuous integration to ensure they remain correct.</p> <p>Light-weight, differentiable finite element analysis package.</p> <p>Finite element primitives used by :mod:<code>tofea</code>.</p> <p>Finite element solvers for 2D problems.</p> <p>Autograd primitives used by the finite element routines.</p> <p>Linear system solver abstractions.</p>"},{"location":"reference/#tofea.elements.Element","title":"<code>Element</code>  <code>dataclass</code>","text":"<p>Base dataclass for finite elements.</p> Source code in <code>tofea/elements.py</code> <pre><code>@dataclass(frozen=True, slots=True, kw_only=True)\nclass Element:\n    \"\"\"Base dataclass for finite elements.\"\"\"\n\n    dx: float = 0.5\n    dy: float = 0.5\n    dz: float = 0.5\n    eps: float = 1e-6\n    dtype: type = np.float64\n</code></pre>"},{"location":"reference/#tofea.elements.Q4Element","title":"<code>Q4Element</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Element</code></p> <p>Four-node quadrilateral element.</p> <p>This class provides utilities shared by all quadrilateral elements implemented in :mod:<code>tofea</code>, namely Gauss quadrature points and the gradients of the bilinear shape functions.  Having these helpers in a common base class avoids code duplication in the concrete element implementations and gives this abstraction a clear purpose.</p> Source code in <code>tofea/elements.py</code> <pre><code>class Q4Element(Element):\n    \"\"\"Four-node quadrilateral element.\n\n    This class provides utilities shared by all quadrilateral elements\n    implemented in :mod:`tofea`, namely Gauss quadrature points and the\n    gradients of the bilinear shape functions.  Having these helpers in a\n    common base class avoids code duplication in the concrete element\n    implementations and gives this abstraction a clear purpose.\n    \"\"\"\n\n    @staticmethod\n    def gauss_points() -&gt; list[tuple[float, float]]:\n        \"\"\"Return the points for 2x2 Gauss quadrature.\"\"\"\n\n        gp = 1 / np.sqrt(3)\n        return [(-gp, -gp), (gp, -gp), (gp, gp), (-gp, gp)]\n\n    def grad_shape_funcs(self, xi: float, eta: float) -&gt; tuple[NDArray, NDArray]:\n        \"\"\"Return shape function gradients for local coordinates.\"\"\"\n\n        dN_dxi: NDArray = np.array(\n            [\n                -0.25 * (1 - eta),\n                0.25 * (1 - eta),\n                0.25 * (1 + eta),\n                -0.25 * (1 + eta),\n            ],\n            dtype=self.dtype,\n        )\n        dN_deta: NDArray = np.array(\n            [\n                -0.25 * (1 - xi),\n                -0.25 * (1 + xi),\n                0.25 * (1 + xi),\n                0.25 * (1 - xi),\n            ],\n            dtype=self.dtype,\n        )\n        return dN_dxi, dN_deta\n</code></pre>"},{"location":"reference/#tofea.elements.Q4Element.gauss_points","title":"<code>gauss_points()</code>  <code>staticmethod</code>","text":"<p>Return the points for 2x2 Gauss quadrature.</p> Source code in <code>tofea/elements.py</code> <pre><code>@staticmethod\ndef gauss_points() -&gt; list[tuple[float, float]]:\n    \"\"\"Return the points for 2x2 Gauss quadrature.\"\"\"\n\n    gp = 1 / np.sqrt(3)\n    return [(-gp, -gp), (gp, -gp), (gp, gp), (-gp, gp)]\n</code></pre>"},{"location":"reference/#tofea.elements.Q4Element.grad_shape_funcs","title":"<code>grad_shape_funcs(xi, eta)</code>","text":"<p>Return shape function gradients for local coordinates.</p> Source code in <code>tofea/elements.py</code> <pre><code>def grad_shape_funcs(self, xi: float, eta: float) -&gt; tuple[NDArray, NDArray]:\n    \"\"\"Return shape function gradients for local coordinates.\"\"\"\n\n    dN_dxi: NDArray = np.array(\n        [\n            -0.25 * (1 - eta),\n            0.25 * (1 - eta),\n            0.25 * (1 + eta),\n            -0.25 * (1 + eta),\n        ],\n        dtype=self.dtype,\n    )\n    dN_deta: NDArray = np.array(\n        [\n            -0.25 * (1 - xi),\n            -0.25 * (1 + xi),\n            0.25 * (1 + xi),\n            0.25 * (1 - xi),\n        ],\n        dtype=self.dtype,\n    )\n    return dN_dxi, dN_deta\n</code></pre>"},{"location":"reference/#tofea.elements.Q4Element_K","title":"<code>Q4Element_K</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Q4Element</code></p> <p>Plane stress elasticity element.</p> Source code in <code>tofea/elements.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass Q4Element_K(Q4Element):\n    \"\"\"Plane stress elasticity element.\"\"\"\n\n    e: float = 1.0\n    nu: float = 1 / 3\n\n    @cached_property\n    def element(self) -&gt; NDArray:\n        \"\"\"Return the 8x8 stiffness matrix for the element.\n\n        The matrix is assembled using 2x2 Gauss quadrature instead of the\n        symbolic integration previously used.  This avoids the costly SymPy\n        computations and speeds up object construction significantly while\n        maintaining numerical precision.\n\n        Returns\n        -------\n        numpy.ndarray\n            Stiffness matrix of shape ``(8, 8)``.\n\n        Examples\n        --------\n        &gt;&gt;&gt; from tofea.elements import Q4Element_K\n        &gt;&gt;&gt; Q4Element_K().element.shape\n        (8, 8)\n        \"\"\"\n\n        C: NDArray = (self.e / (1 - self.nu**2)) * np.array(\n            [[1, self.nu, 0], [self.nu, 1, 0], [0, 0, (1 - self.nu) / 2]],\n            dtype=self.dtype,\n        )\n\n        K: NDArray = np.zeros((8, 8), dtype=self.dtype)\n\n        for xi, eta in self.gauss_points():\n            dN_dxi, dN_deta = self.grad_shape_funcs(xi, eta)\n\n            B: NDArray = np.zeros((3, 8), dtype=self.dtype)\n            for i in range(4):\n                B[0, 2 * i] = dN_dxi[i] / self.dx\n                B[1, 2 * i + 1] = dN_deta[i] / self.dy\n                B[2, 2 * i] = dN_deta[i] / self.dy\n                B[2, 2 * i + 1] = dN_dxi[i] / self.dx\n\n            K += (B.T @ C @ B) * self.dx * self.dy\n\n        K[np.abs(K) &lt; self.eps] = 0\n        return K\n</code></pre>"},{"location":"reference/#tofea.elements.Q4Element_K.element","title":"<code>element</code>  <code>cached</code> <code>property</code>","text":"<p>Return the 8x8 stiffness matrix for the element.</p> <p>The matrix is assembled using 2x2 Gauss quadrature instead of the symbolic integration previously used.  This avoids the costly SymPy computations and speeds up object construction significantly while maintaining numerical precision.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Stiffness matrix of shape <code>(8, 8)</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tofea.elements import Q4Element_K\n&gt;&gt;&gt; Q4Element_K().element.shape\n(8, 8)\n</code></pre>"},{"location":"reference/#tofea.elements.Q4Element_T","title":"<code>Q4Element_T</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Q4Element</code></p> <p>Heat conductivity element.</p> Source code in <code>tofea/elements.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass Q4Element_T(Q4Element):\n    \"\"\"Heat conductivity element.\"\"\"\n\n    k: float = 1.0\n\n    @cached_property\n    def element(self) -&gt; NDArray:\n        \"\"\"Return the 4x4 conductivity matrix for the element.\n\n        Similar to :class:`Q4Element_K`, the matrix is assembled numerically\n        using 2x2 Gauss quadrature.  This removes the dependency on SymPy for\n        runtime calculations and considerably reduces initialization time.\n\n        Returns\n        -------\n        numpy.ndarray\n            Conductivity matrix of shape ``(4, 4)``.\n\n        Examples\n        --------\n        &gt;&gt;&gt; from tofea.elements import Q4Element_T\n        &gt;&gt;&gt; Q4Element_T().element.shape\n        (4, 4)\n        \"\"\"\n\n        C: NDArray = np.array([[self.k, 0], [0, self.k]], dtype=self.dtype)\n\n        K: NDArray = np.zeros((4, 4), dtype=self.dtype)\n\n        for xi, eta in self.gauss_points():\n            dN_dxi, dN_deta = self.grad_shape_funcs(xi, eta)\n\n            B: NDArray = np.zeros((2, 4), dtype=self.dtype)\n            for i in range(4):\n                B[0, i] = dN_dxi[i] / self.dx\n                B[1, i] = dN_deta[i] / self.dy\n\n            K += (B.T @ C @ B) * self.dx * self.dy\n\n        K[np.abs(K) &lt; self.eps] = 0\n        return K\n</code></pre>"},{"location":"reference/#tofea.elements.Q4Element_T.element","title":"<code>element</code>  <code>cached</code> <code>property</code>","text":"<p>Return the 4x4 conductivity matrix for the element.</p> <p>Similar to :class:<code>Q4Element_K</code>, the matrix is assembled numerically using 2x2 Gauss quadrature.  This removes the dependency on SymPy for runtime calculations and considerably reduces initialization time.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Conductivity matrix of shape <code>(4, 4)</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tofea.elements import Q4Element_T\n&gt;&gt;&gt; Q4Element_T().element.shape\n(4, 4)\n</code></pre>"},{"location":"reference/#tofea.fea2d.FEA2D","title":"<code>FEA2D</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for 2D finite element models.</p> <p>Parameters:</p> Name Type Description Default <code>fixed</code> <code>NDArray[bool_]</code> <p>Boolean mask indicating which degrees of freedom are fixed.</p> required <code>solver</code> <code>str</code> <p>Name of the backend solver to use.</p> <code>DEFAULT_SOLVER</code> <code>dx</code> <code>float</code> <p>Element dimensions in <code>x</code> and <code>y</code> direction.</p> <code>0.5</code> <code>dy</code> <code>float</code> <p>Element dimensions in <code>x</code> and <code>y</code> direction.</p> <code>0.5</code> Notes <p>Subclasses must provide the element matrix and a mapping from element degrees of freedom to system degrees of freedom.</p> Source code in <code>tofea/fea2d.py</code> <pre><code>@dataclass\nclass FEA2D(ABC):\n    \"\"\"Abstract base class for 2D finite element models.\n\n    Parameters\n    ----------\n    fixed\n        Boolean mask indicating which degrees of freedom are fixed.\n    solver\n        Name of the backend solver to use.\n    dx, dy\n        Element dimensions in ``x`` and ``y`` direction.\n\n    Notes\n    -----\n    Subclasses must provide the element matrix and a mapping from element\n    degrees of freedom to system degrees of freedom.\n    \"\"\"\n\n    fixed: NDArray[np.bool_]\n    solver: str = DEFAULT_SOLVER\n    dx: float = 0.5\n    dy: float = 0.5\n\n    @property\n    @abstractmethod\n    def dof_dim(self) -&gt; int: ...\n\n    @property\n    @abstractmethod\n    def element(self) -&gt; NDArray: ...\n\n    @property\n    @abstractmethod\n    def dofmap(self) -&gt; NDArray[np.uint32]: ...\n\n    @property\n    def shape(self) -&gt; tuple[int, int]:\n        \"\"\"Number of elements in :math:`x` and :math:`y` direction.\"\"\"\n\n        nx, ny = self.fixed.shape[:2]\n        return nx - 1, ny - 1\n\n    @cached_property\n    def dofs(self) -&gt; NDArray[np.uint32]:\n        \"\"\"Indices of all degrees of freedom.\"\"\"\n\n        return np.arange(self.fixed.size, dtype=np.uint32)\n\n    @cached_property\n    def fixdofs(self) -&gt; NDArray[np.uint32]:\n        \"\"\"Indices of fixed degrees of freedom.\"\"\"\n\n        return self.dofs[self.fixed.ravel()]\n\n    @cached_property\n    def freedofs(self) -&gt; NDArray[np.uint32]:\n        \"\"\"Indices of free degrees of freedom.\"\"\"\n\n        return self.dofs[~self.fixed.ravel()]\n\n    @cached_property\n    def _solver(self) -&gt; Solver:\n        \"\"\"Backend solver instance.\"\"\"\n\n        return get_solver(self.solver)\n\n    @cached_property\n    def index_map(self) -&gt; NDArray[np.uint32]:\n        \"\"\"Permutation that places free DOFs first.\"\"\"\n\n        indices = np.concatenate([self.freedofs, self.fixdofs])\n        imap = np.zeros_like(self.dofs)\n        imap[indices] = self.dofs\n        return imap\n\n    @cached_property\n    def e2sdofmap(self) -&gt; NDArray[np.uint32]:\n        \"\"\"Map each element to its system DOF indices.\"\"\"\n\n        nx, ny = self.shape\n        x, y = np.unravel_index(np.arange(nx * ny), (nx, ny))\n        idxs = self.dof_dim * (y + x * (ny + 1))\n        return np.add(self.dofmap[None], idxs[:, None].astype(np.uint32))\n\n    @cached_property\n    def e2sdofmap_reshaped(self) -&gt; NDArray[np.uint32]:\n        \"\"\"Element mapping reshaped for tensor operations.\"\"\"\n\n        return np.reshape(self.e2sdofmap.T, (-1, *self.shape))\n\n    @cached_property\n    def keep_indices(\n        self,\n    ) -&gt; tuple[NDArray[np.bool_], NDArray[np.uint32]]:\n        \"\"\"Indices for assembling the global matrix.\"\"\"\n\n        i, j = np.meshgrid(range(len(self.dofmap)), range(len(self.dofmap)))\n        ix = self.e2sdofmap[:, i].ravel()\n        iy = self.e2sdofmap[:, j].ravel()\n        keep = np.isin(ix, self.freedofs) &amp; np.isin(iy, self.freedofs)\n        indices = np.stack([self.index_map[ix][keep], self.index_map[iy][keep]])\n        return keep, indices\n\n    def global_mat(self, x: NDArray) -&gt; tuple[NDArray, NDArray]:\n        \"\"\"Assemble global matrix from element data.\"\"\"\n\n        x = np.reshape(x, (-1, 1, 1)) * self.element[None]\n        x = x.ravel()\n        keep, indices = self.keep_indices\n        return x[keep], indices\n\n    def solve(self, x: NDArray, b: NDArray) -&gt; NDArray:\n        \"\"\"Solve ``K(x) u = b`` for ``u``.\"\"\"\n\n        data, indices = self.global_mat(x)\n        u_nz = solve_coo(data, indices, b.ravel()[self.freedofs], self._solver)\n        u = anp.concatenate([u_nz, np.zeros(len(self.fixdofs))])[self.index_map]\n        return u\n\n    def _self_adjoint_objective(self, x: NDArray, b: NDArray) -&gt; NDArray:\n        \"\"\"Internal method to compute a self-adjoint objective.\"\"\"\n\n        data, indices = self.global_mat(x)\n        free_rhs = b.ravel()[self.freedofs]\n        objective, _ = solve_and_compute_self_adjoint_objective(\n            data, indices, free_rhs, self._solver\n        )\n        return objective\n</code></pre>"},{"location":"reference/#tofea.fea2d.FEA2D.dofs","title":"<code>dofs</code>  <code>cached</code> <code>property</code>","text":"<p>Indices of all degrees of freedom.</p>"},{"location":"reference/#tofea.fea2d.FEA2D.e2sdofmap","title":"<code>e2sdofmap</code>  <code>cached</code> <code>property</code>","text":"<p>Map each element to its system DOF indices.</p>"},{"location":"reference/#tofea.fea2d.FEA2D.e2sdofmap_reshaped","title":"<code>e2sdofmap_reshaped</code>  <code>cached</code> <code>property</code>","text":"<p>Element mapping reshaped for tensor operations.</p>"},{"location":"reference/#tofea.fea2d.FEA2D.fixdofs","title":"<code>fixdofs</code>  <code>cached</code> <code>property</code>","text":"<p>Indices of fixed degrees of freedom.</p>"},{"location":"reference/#tofea.fea2d.FEA2D.freedofs","title":"<code>freedofs</code>  <code>cached</code> <code>property</code>","text":"<p>Indices of free degrees of freedom.</p>"},{"location":"reference/#tofea.fea2d.FEA2D.index_map","title":"<code>index_map</code>  <code>cached</code> <code>property</code>","text":"<p>Permutation that places free DOFs first.</p>"},{"location":"reference/#tofea.fea2d.FEA2D.keep_indices","title":"<code>keep_indices</code>  <code>cached</code> <code>property</code>","text":"<p>Indices for assembling the global matrix.</p>"},{"location":"reference/#tofea.fea2d.FEA2D.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Number of elements in :math:<code>x</code> and :math:<code>y</code> direction.</p>"},{"location":"reference/#tofea.fea2d.FEA2D.global_mat","title":"<code>global_mat(x)</code>","text":"<p>Assemble global matrix from element data.</p> Source code in <code>tofea/fea2d.py</code> <pre><code>def global_mat(self, x: NDArray) -&gt; tuple[NDArray, NDArray]:\n    \"\"\"Assemble global matrix from element data.\"\"\"\n\n    x = np.reshape(x, (-1, 1, 1)) * self.element[None]\n    x = x.ravel()\n    keep, indices = self.keep_indices\n    return x[keep], indices\n</code></pre>"},{"location":"reference/#tofea.fea2d.FEA2D.solve","title":"<code>solve(x, b)</code>","text":"<p>Solve <code>K(x) u = b</code> for <code>u</code>.</p> Source code in <code>tofea/fea2d.py</code> <pre><code>def solve(self, x: NDArray, b: NDArray) -&gt; NDArray:\n    \"\"\"Solve ``K(x) u = b`` for ``u``.\"\"\"\n\n    data, indices = self.global_mat(x)\n    u_nz = solve_coo(data, indices, b.ravel()[self.freedofs], self._solver)\n    u = anp.concatenate([u_nz, np.zeros(len(self.fixdofs))])[self.index_map]\n    return u\n</code></pre>"},{"location":"reference/#tofea.fea2d.FEA2D_K","title":"<code>FEA2D_K</code>  <code>dataclass</code>","text":"<p>               Bases: <code>FEA2D</code></p> <p>Finite element model for compliance problems.</p> <p>This model solves small deformation elasticity problems using bilinear quadrilateral elements.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; fixed = np.zeros((2, 2, 2), dtype=bool)\n&gt;&gt;&gt; fem = FEA2D_K(fixed)\n&gt;&gt;&gt; fem.element.shape\n(8, 8)\n</code></pre> Source code in <code>tofea/fea2d.py</code> <pre><code>@dataclass\nclass FEA2D_K(FEA2D):\n    \"\"\"Finite element model for compliance problems.\n\n    This model solves small deformation elasticity problems using bilinear\n    quadrilateral elements.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; fixed = np.zeros((2, 2, 2), dtype=bool)\n    &gt;&gt;&gt; fem = FEA2D_K(fixed)\n    &gt;&gt;&gt; fem.element.shape\n    (8, 8)\n    \"\"\"\n\n    dof_dim: int = 2\n    e: float = 1.0\n    nu: float = 1 / 3\n\n    @cached_property\n    def element(self) -&gt; NDArray:\n        \"\"\"Element stiffness matrix.\"\"\"\n        return Q4Element_K(e=self.e, nu=self.nu, dx=self.dx, dy=self.dy).element\n\n    @cached_property\n    def dofmap(self) -&gt; NDArray[np.uint32]:\n        \"\"\"Mapping of element DOFs to system DOFs.\"\"\"\n        _, nely = self.shape\n        b = np.arange(2 * (nely + 1), 2 * (nely + 1) + 2)\n        a = b + 2\n        return np.r_[2, 3, a, b, 0, 1].astype(np.uint32)\n\n    def displacement(self, x: NDArray, b: NDArray) -&gt; NDArray:\n        \"\"\"Return displacement field for density ``x`` and load ``b``.\n\n        This is a general-purpose method that returns the full displacement field,\n        suitable for constructing arbitrary objective functions. If your\n        objective is compliance minimization, using the ``compliance()`` method is\n        significantly more performant.\n        \"\"\"\n\n        return self.solve(x, b)\n\n    def compliance(self, x: NDArray, b: NDArray) -&gt; NDArray:\n        \"\"\"Computes the compliance objective using a highly efficient self-adjoint pathway.\n\n        This method is optimized for compliance minimization and avoids a redundant\n        adjoint solve during gradient computation. For constructing arbitrary objective\n        functions based on the displacement field, use the :meth:`displacement` method\n        instead.\n\n        Parameters\n        ----------\n        x : array-like\n            Material density field.\n        b : array-like\n            Load vector.\n\n        Returns\n        -------\n        numpy.ndarray\n            The scalar compliance value.\n        \"\"\"\n\n        return self._self_adjoint_objective(x, b)\n</code></pre>"},{"location":"reference/#tofea.fea2d.FEA2D_K.dofmap","title":"<code>dofmap</code>  <code>cached</code> <code>property</code>","text":"<p>Mapping of element DOFs to system DOFs.</p>"},{"location":"reference/#tofea.fea2d.FEA2D_K.element","title":"<code>element</code>  <code>cached</code> <code>property</code>","text":"<p>Element stiffness matrix.</p>"},{"location":"reference/#tofea.fea2d.FEA2D_K.compliance","title":"<code>compliance(x, b)</code>","text":"<p>Computes the compliance objective using a highly efficient self-adjoint pathway.</p> <p>This method is optimized for compliance minimization and avoids a redundant adjoint solve during gradient computation. For constructing arbitrary objective functions based on the displacement field, use the :meth:<code>displacement</code> method instead.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array - like</code> <p>Material density field.</p> required <code>b</code> <code>array - like</code> <p>Load vector.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The scalar compliance value.</p> Source code in <code>tofea/fea2d.py</code> <pre><code>def compliance(self, x: NDArray, b: NDArray) -&gt; NDArray:\n    \"\"\"Computes the compliance objective using a highly efficient self-adjoint pathway.\n\n    This method is optimized for compliance minimization and avoids a redundant\n    adjoint solve during gradient computation. For constructing arbitrary objective\n    functions based on the displacement field, use the :meth:`displacement` method\n    instead.\n\n    Parameters\n    ----------\n    x : array-like\n        Material density field.\n    b : array-like\n        Load vector.\n\n    Returns\n    -------\n    numpy.ndarray\n        The scalar compliance value.\n    \"\"\"\n\n    return self._self_adjoint_objective(x, b)\n</code></pre>"},{"location":"reference/#tofea.fea2d.FEA2D_K.displacement","title":"<code>displacement(x, b)</code>","text":"<p>Return displacement field for density <code>x</code> and load <code>b</code>.</p> <p>This is a general-purpose method that returns the full displacement field, suitable for constructing arbitrary objective functions. If your objective is compliance minimization, using the <code>compliance()</code> method is significantly more performant.</p> Source code in <code>tofea/fea2d.py</code> <pre><code>def displacement(self, x: NDArray, b: NDArray) -&gt; NDArray:\n    \"\"\"Return displacement field for density ``x`` and load ``b``.\n\n    This is a general-purpose method that returns the full displacement field,\n    suitable for constructing arbitrary objective functions. If your\n    objective is compliance minimization, using the ``compliance()`` method is\n    significantly more performant.\n    \"\"\"\n\n    return self.solve(x, b)\n</code></pre>"},{"location":"reference/#tofea.fea2d.FEA2D_T","title":"<code>FEA2D_T</code>  <code>dataclass</code>","text":"<p>               Bases: <code>FEA2D</code></p> <p>Finite element model for heat conduction problems.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; fixed = np.zeros((2, 2), dtype=bool)\n&gt;&gt;&gt; fem = FEA2D_T(fixed)\n&gt;&gt;&gt; fem.element.shape\n(4, 4)\n</code></pre> Source code in <code>tofea/fea2d.py</code> <pre><code>@dataclass\nclass FEA2D_T(FEA2D):\n    \"\"\"Finite element model for heat conduction problems.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; fixed = np.zeros((2, 2), dtype=bool)\n    &gt;&gt;&gt; fem = FEA2D_T(fixed)\n    &gt;&gt;&gt; fem.element.shape\n    (4, 4)\n    \"\"\"\n\n    dof_dim: int = 1\n    k: float = 1.0\n\n    @cached_property\n    def element(self) -&gt; NDArray:\n        \"\"\"Element conductivity matrix.\"\"\"\n        return Q4Element_T(k=self.k, dx=self.dx, dy=self.dy).element\n\n    @cached_property\n    def dofmap(self) -&gt; NDArray[np.uint32]:\n        \"\"\"Mapping of element DOFs to system DOFs.\"\"\"\n        _, nely = self.shape\n        return np.r_[1, (nely + 2), (nely + 1), 0].astype(np.uint32)\n\n    def temperature(self, x: NDArray, b: NDArray) -&gt; NDArray:\n        \"\"\"Return temperature field for density ``x`` and load ``b``.\n\n        This is a general-purpose method that returns the full temperature field,\n        suitable for constructing arbitrary objective functions. If your objective\n        is thermal compliance minimization, using the ``thermal_compliance()``\n        method is significantly more performant.\n        \"\"\"\n\n        return self.solve(x, b)\n\n    def thermal_compliance(self, x: NDArray, b: NDArray) -&gt; NDArray:\n        \"\"\"Computes the thermal compliance objective using a highly efficient self-adjoint pathway.\n\n        This method is optimized for thermal compliance minimization and avoids a\n        redundant adjoint solve during gradient computation. For constructing arbitrary\n        objective functions based on the temperature field, use the :meth:`temperature`\n        method instead.\n\n        Parameters\n        ----------\n        x : array-like\n            Material density field.\n        b : array-like\n            Heat load vector.\n\n        Returns\n        -------\n        numpy.ndarray\n            The scalar thermal compliance value.\n        \"\"\"\n\n        return self._self_adjoint_objective(x, b)\n</code></pre>"},{"location":"reference/#tofea.fea2d.FEA2D_T.dofmap","title":"<code>dofmap</code>  <code>cached</code> <code>property</code>","text":"<p>Mapping of element DOFs to system DOFs.</p>"},{"location":"reference/#tofea.fea2d.FEA2D_T.element","title":"<code>element</code>  <code>cached</code> <code>property</code>","text":"<p>Element conductivity matrix.</p>"},{"location":"reference/#tofea.fea2d.FEA2D_T.temperature","title":"<code>temperature(x, b)</code>","text":"<p>Return temperature field for density <code>x</code> and load <code>b</code>.</p> <p>This is a general-purpose method that returns the full temperature field, suitable for constructing arbitrary objective functions. If your objective is thermal compliance minimization, using the <code>thermal_compliance()</code> method is significantly more performant.</p> Source code in <code>tofea/fea2d.py</code> <pre><code>def temperature(self, x: NDArray, b: NDArray) -&gt; NDArray:\n    \"\"\"Return temperature field for density ``x`` and load ``b``.\n\n    This is a general-purpose method that returns the full temperature field,\n    suitable for constructing arbitrary objective functions. If your objective\n    is thermal compliance minimization, using the ``thermal_compliance()``\n    method is significantly more performant.\n    \"\"\"\n\n    return self.solve(x, b)\n</code></pre>"},{"location":"reference/#tofea.fea2d.FEA2D_T.thermal_compliance","title":"<code>thermal_compliance(x, b)</code>","text":"<p>Computes the thermal compliance objective using a highly efficient self-adjoint pathway.</p> <p>This method is optimized for thermal compliance minimization and avoids a redundant adjoint solve during gradient computation. For constructing arbitrary objective functions based on the temperature field, use the :meth:<code>temperature</code> method instead.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array - like</code> <p>Material density field.</p> required <code>b</code> <code>array - like</code> <p>Heat load vector.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The scalar thermal compliance value.</p> Source code in <code>tofea/fea2d.py</code> <pre><code>def thermal_compliance(self, x: NDArray, b: NDArray) -&gt; NDArray:\n    \"\"\"Computes the thermal compliance objective using a highly efficient self-adjoint pathway.\n\n    This method is optimized for thermal compliance minimization and avoids a\n    redundant adjoint solve during gradient computation. For constructing arbitrary\n    objective functions based on the temperature field, use the :meth:`temperature`\n    method instead.\n\n    Parameters\n    ----------\n    x : array-like\n        Material density field.\n    b : array-like\n        Heat load vector.\n\n    Returns\n    -------\n    numpy.ndarray\n        The scalar thermal compliance value.\n    \"\"\"\n\n    return self._self_adjoint_objective(x, b)\n</code></pre>"},{"location":"reference/#tofea.primitives.solve_and_compute_self_adjoint_objective","title":"<code>solve_and_compute_self_adjoint_objective(entries, indices, rhs, solver)</code>","text":"<p>Solve <code>K u = b</code> and return the self-adjoint objective and solution.</p> Source code in <code>tofea/primitives.py</code> <pre><code>@primitive\ndef solve_and_compute_self_adjoint_objective(\n    entries: NDArray,\n    indices: tuple[NDArray[np.int_], NDArray[np.int_]],\n    rhs: NDArray,\n    solver: Solver,\n) -&gt; tuple[NDArray, NDArray]:\n    \"\"\"Solve ``K u = b`` and return the self-adjoint objective and solution.\"\"\"\n\n    u_nz = solve_coo(entries, indices, rhs, solver)\n    objective = anp.dot(u_nz, rhs)\n    return objective, u_nz\n</code></pre>"},{"location":"reference/#tofea.primitives.solve_and_compute_self_adjoint_objective_vjp","title":"<code>solve_and_compute_self_adjoint_objective_vjp(ans, entries, indices, rhs, solver)</code>","text":"<p>Reverse-mode derivative for <code>solve_and_compute_self_adjoint_objective</code>.</p> Source code in <code>tofea/primitives.py</code> <pre><code>def solve_and_compute_self_adjoint_objective_vjp(\n    ans: tuple[NDArray, NDArray],\n    entries: NDArray,  # noqa: ARG001\n    indices: tuple[NDArray[np.int_], NDArray[np.int_]],\n    rhs: NDArray,  # noqa: ARG001\n    solver: Solver,  # noqa: ARG001\n) -&gt; Callable[[NDArray | tuple[NDArray, NDArray]], NDArray]:\n    \"\"\"Reverse-mode derivative for ``solve_and_compute_self_adjoint_objective``.\"\"\"\n\n    _, u_nz = ans\n\n    def vjp(g: NDArray | tuple[NDArray, NDArray]) -&gt; NDArray:\n        if not isinstance(g, np.ndarray):\n            g = g[0]\n        i, j = indices\n        return -g * u_nz[i] * u_nz[j]\n\n    return vjp\n</code></pre>"},{"location":"reference/#tofea.primitives.solve_coo","title":"<code>solve_coo(entries, indices, rhs, solver)</code>","text":"<p>Solve a sparse linear system in COO format.</p> <p>Parameters:</p> Name Type Description Default <code>entries</code> <code>array - like</code> <p>Non-zero matrix entries.</p> required <code>indices</code> <code>tuple[array - like, array - like]</code> <p>Row and column indices for <code>entries</code>.</p> required <code>rhs</code> <code>array - like</code> <p>Right-hand side vector.</p> required <code>solver</code> <code>Solver</code> <p>Factorization backend used to solve the system.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Solution vector.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from scipy.sparse import coo_matrix\n&gt;&gt;&gt; from tofea.primitives import solve_coo\n&gt;&gt;&gt; from tofea.solvers import get_solver\n&gt;&gt;&gt; m = coo_matrix([[4, 1], [1, 3]])\n&gt;&gt;&gt; b = np.array([1, 2])\n&gt;&gt;&gt; solve_coo(m.data, (m.row, m.col), b, get_solver(\"SuperLU\"))\narray([0.09090909, 0.63636364])\n</code></pre> Source code in <code>tofea/primitives.py</code> <pre><code>@primitive\ndef solve_coo(\n    entries: NDArray,\n    indices: tuple[NDArray[np.int_], NDArray[np.int_]],\n    rhs: NDArray,\n    solver: Solver,\n) -&gt; NDArray:\n    \"\"\"Solve a sparse linear system in COO format.\n\n    Parameters\n    ----------\n    entries : array-like\n        Non-zero matrix entries.\n    indices : tuple[array-like, array-like]\n        Row and column indices for ``entries``.\n    rhs : array-like\n        Right-hand side vector.\n    solver : tofea.solvers.Solver\n        Factorization backend used to solve the system.\n\n    Returns\n    -------\n    numpy.ndarray\n        Solution vector.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from scipy.sparse import coo_matrix\n    &gt;&gt;&gt; from tofea.primitives import solve_coo\n    &gt;&gt;&gt; from tofea.solvers import get_solver\n    &gt;&gt;&gt; m = coo_matrix([[4, 1], [1, 3]])\n    &gt;&gt;&gt; b = np.array([1, 2])\n    &gt;&gt;&gt; solve_coo(m.data, (m.row, m.col), b, get_solver(\"SuperLU\"))\n    array([0.09090909, 0.63636364])\n    \"\"\"\n\n    a = coo_matrix((entries, indices)).tocsc()\n    solver.clear()\n    solver.factor(a)\n    return solver.solve(rhs)\n</code></pre>"},{"location":"reference/#tofea.primitives.solve_coo_b_jvp","title":"<code>solve_coo_b_jvp(g, x, entries, indices, rhs, solver)</code>","text":"<p>Forward-mode derivative of :func:<code>solve_coo</code> with respect to <code>rhs</code>.</p> Source code in <code>tofea/primitives.py</code> <pre><code>def solve_coo_b_jvp(\n    g: NDArray,\n    x: NDArray,  # noqa: ARG001\n    entries: NDArray,  # noqa: ARG001\n    indices: tuple[NDArray[np.int_], NDArray[np.int_]],  # noqa: ARG001\n    rhs: NDArray,  # noqa: ARG001\n    solver: Solver,\n) -&gt; NDArray:\n    \"\"\"Forward-mode derivative of :func:`solve_coo` with respect to ``rhs``.\"\"\"\n\n    return solver.solve(g)\n</code></pre>"},{"location":"reference/#tofea.primitives.solve_coo_b_vjp","title":"<code>solve_coo_b_vjp(ans, entries, indices, rhs, solver)</code>","text":"<p>Reverse-mode derivative of :func:<code>solve_coo</code> for <code>rhs</code>.</p> Source code in <code>tofea/primitives.py</code> <pre><code>def solve_coo_b_vjp(\n    ans: NDArray,  # noqa: ARG001\n    entries: NDArray,  # noqa: ARG001\n    indices: tuple[NDArray[np.int_], NDArray[np.int_]],  # noqa: ARG001\n    rhs: NDArray,  # noqa: ARG001\n    solver: Solver,\n) -&gt; Callable[[NDArray], NDArray]:\n    \"\"\"Reverse-mode derivative of :func:`solve_coo` for ``rhs``.\"\"\"\n\n    def vjp(g: NDArray) -&gt; NDArray:\n        return solver.solve(g, transpose=True)\n\n    return vjp\n</code></pre>"},{"location":"reference/#tofea.primitives.solve_coo_entries_jvp","title":"<code>solve_coo_entries_jvp(g, x, entries, indices, rhs, solver)</code>","text":"<p>Forward-mode derivative of :func:<code>solve_coo</code> with respect to <code>entries</code>.</p> Source code in <code>tofea/primitives.py</code> <pre><code>def solve_coo_entries_jvp(\n    g: NDArray,\n    x: NDArray,\n    entries: NDArray,  # noqa: ARG001\n    indices: tuple[NDArray[np.int_], NDArray[np.int_]],\n    rhs: NDArray,  # noqa: ARG001\n    solver: Solver,\n) -&gt; NDArray:\n    \"\"\"Forward-mode derivative of :func:`solve_coo` with respect to ``entries``.\"\"\"\n\n    a = coo_matrix((g, indices)).tocsc()\n    return solver.solve(-(a @ x))\n</code></pre>"},{"location":"reference/#tofea.primitives.solve_coo_entries_vjp","title":"<code>solve_coo_entries_vjp(ans, entries, indices, rhs, solver)</code>","text":"<p>Reverse-mode derivative of :func:<code>solve_coo</code> for <code>entries</code>.</p> Source code in <code>tofea/primitives.py</code> <pre><code>def solve_coo_entries_vjp(\n    ans: NDArray,\n    entries: NDArray,  # noqa: ARG001\n    indices: tuple[NDArray[np.int_], NDArray[np.int_]],\n    rhs: NDArray,  # noqa: ARG001\n    solver: Solver,\n) -&gt; Callable[[NDArray], NDArray]:\n    \"\"\"Reverse-mode derivative of :func:`solve_coo` for ``entries``.\"\"\"\n\n    def vjp(g: NDArray) -&gt; NDArray:\n        x = solver.solve(g, transpose=True)\n        i, j = indices\n        return -x[i] * ans[j]\n\n    return vjp\n</code></pre>"},{"location":"reference/#tofea.solvers.Solver","title":"<code>Solver</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract interface for linear solvers.</p> Source code in <code>tofea/solvers.py</code> <pre><code>class Solver(ABC):\n    \"\"\"Abstract interface for linear solvers.\"\"\"\n\n    @abstractmethod\n    def factor(self, m: csc_matrix) -&gt; None: ...\n\n    @abstractmethod\n    def solve(self, rhs: NDArray, transpose: bool = False) -&gt; NDArray: ...\n\n    @abstractmethod\n    def clear(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/#tofea.solvers.SuperLU","title":"<code>SuperLU</code>","text":"<p>               Bases: <code>Solver</code></p> <p><code>scipy.sparse.linalg.splu</code> wrapper.</p> Source code in <code>tofea/solvers.py</code> <pre><code>class SuperLU(Solver):\n    \"\"\"`scipy.sparse.linalg.splu` wrapper.\"\"\"\n\n    def __init__(self, **options: float | int | bool | str | Mapping[str, bool]) -&gt; None:\n        \"\"\"Create a new ``SuperLU`` solver instance.\"\"\"\n        # store solver-specific context on the instance to avoid cross-talk\n        self._ctx: dict[str, Any] = {\"splu\": partial(splu, **options)}\n\n    def factor(self, m: csc_matrix) -&gt; None:\n        \"\"\"Compute the factorization of ``m``.\"\"\"\n        self._ctx[\"factorization\"] = self._ctx[\"splu\"](m)\n\n    def solve(self, rhs: NDArray, transpose: bool = False) -&gt; NDArray:\n        \"\"\"Solve the linear system.\"\"\"\n        return self._ctx[\"factorization\"].solve(rhs, trans=\"T\" if transpose else \"N\")\n\n    def clear(self) -&gt; None:\n        \"\"\"Remove cached factorization.\"\"\"\n        self._ctx.pop(\"factorization\", None)\n</code></pre>"},{"location":"reference/#tofea.solvers.SuperLU.__init__","title":"<code>__init__(**options)</code>","text":"<p>Create a new <code>SuperLU</code> solver instance.</p> Source code in <code>tofea/solvers.py</code> <pre><code>def __init__(self, **options: float | int | bool | str | Mapping[str, bool]) -&gt; None:\n    \"\"\"Create a new ``SuperLU`` solver instance.\"\"\"\n    # store solver-specific context on the instance to avoid cross-talk\n    self._ctx: dict[str, Any] = {\"splu\": partial(splu, **options)}\n</code></pre>"},{"location":"reference/#tofea.solvers.SuperLU.clear","title":"<code>clear()</code>","text":"<p>Remove cached factorization.</p> Source code in <code>tofea/solvers.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Remove cached factorization.\"\"\"\n    self._ctx.pop(\"factorization\", None)\n</code></pre>"},{"location":"reference/#tofea.solvers.SuperLU.factor","title":"<code>factor(m)</code>","text":"<p>Compute the factorization of <code>m</code>.</p> Source code in <code>tofea/solvers.py</code> <pre><code>def factor(self, m: csc_matrix) -&gt; None:\n    \"\"\"Compute the factorization of ``m``.\"\"\"\n    self._ctx[\"factorization\"] = self._ctx[\"splu\"](m)\n</code></pre>"},{"location":"reference/#tofea.solvers.SuperLU.solve","title":"<code>solve(rhs, transpose=False)</code>","text":"<p>Solve the linear system.</p> Source code in <code>tofea/solvers.py</code> <pre><code>def solve(self, rhs: NDArray, transpose: bool = False) -&gt; NDArray:\n    \"\"\"Solve the linear system.\"\"\"\n    return self._ctx[\"factorization\"].solve(rhs, trans=\"T\" if transpose else \"N\")\n</code></pre>"},{"location":"reference/#tofea.solvers.get_solver","title":"<code>get_solver(solver)</code>","text":"<p>Return a solver instance by name.</p> <p>Parameters:</p> Name Type Description Default <code>solver</code> <code>str</code> <p>Name of the solver implementation. Currently only <code>\"SuperLU\"</code> is available.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tofea.solvers import get_solver, Solver\n&gt;&gt;&gt; s = get_solver(\"SuperLU\")\n&gt;&gt;&gt; isinstance(s, Solver)\nTrue\n</code></pre> Source code in <code>tofea/solvers.py</code> <pre><code>def get_solver(solver: str) -&gt; Solver:\n    \"\"\"Return a solver instance by name.\n\n    Parameters\n    ----------\n    solver\n        Name of the solver implementation. Currently only ``\"SuperLU\"`` is\n        available.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from tofea.solvers import get_solver, Solver\n    &gt;&gt;&gt; s = get_solver(\"SuperLU\")\n    &gt;&gt;&gt; isinstance(s, Solver)\n    True\n    \"\"\"\n    match solver:\n        case \"SuperLU\":\n            return SuperLU(\n                diag_pivot_thresh=0.1,\n                permc_spec=\"MMD_AT_PLUS_A\",\n                options={\"SymmetricMode\": True},\n            )\n        case _:\n            raise ValueError(f\"Invalid solver: {solver}\")\n</code></pre>"}]}