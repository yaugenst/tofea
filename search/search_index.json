{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TOFEA Documentation","text":"<p>Welcome to the TOFEA documentation. This site is generated with MkDocs and contains API reference material extracted from the source code. The examples in the repository show how to solve simple heat conduction and compliance problems using <code>autograd</code> for automatic differentiation.</p> <p>To build the documentation locally use:</p> <pre><code>pip install -e .[docs]\nmkdocs serve\n</code></pre>"},{"location":"reference/","title":"API Reference","text":"<p>This section contains the automatically generated API reference. Each module is documented with <code>mkdocstrings</code> and the examples included in the docstrings are executed as doctests during continuous integration to ensure they remain correct.</p> <p>Light-weight, differentiable finite element analysis package.</p> <p>Finite element primitives used by :mod:<code>tofea</code>.</p> <p>Finite element solvers for 2D problems.</p> <p>Autograd primitives used by the finite element routines.</p> <p>Linear system solver abstractions.</p>"},{"location":"reference/#tofea.elements.Element","title":"<code>Element</code>  <code>dataclass</code>","text":"<p>Base dataclass for finite elements.</p> Source code in <code>tofea/elements.py</code> <pre><code>@dataclass(frozen=True, slots=True, kw_only=True)\nclass Element:\n    \"\"\"Base dataclass for finite elements.\"\"\"\n\n    dx: float = 0.5\n    dy: float = 0.5\n    dz: float = 0.5\n    eps: float = 1e-6\n    dtype: type = np.float64\n\n    @staticmethod\n    def _b_entries(\n        rule: Iterable[int],\n        shape_funcs: Iterable[sympy.Expr],\n        clist: Iterable[sympy.Symbol],\n    ) -&gt; tuple[sympy.Expr, ...]:\n        \"\"\"Return derivatives of ``shape_funcs`` with respect to ``clist``.\n\n        Parameters\n        ----------\n        rule\n            Scaling applied to each shape function before differentiation.\n        shape_funcs\n            Iterable containing the shape functions.\n        clist\n            Symbols with respect to which the derivatives are taken.\n\n        Returns\n        -------\n        tuple[sympy.Expr, ...]\n            The differentiated shape functions.\n\n        Examples\n        --------\n        &gt;&gt;&gt; import sympy\n        &gt;&gt;&gt; x, y = sympy.symbols(\"x y\")\n        &gt;&gt;&gt; Element._b_entries([1, 0], [x * y], [x, y])\n        (y, 0)\n        \"\"\"\n\n        shape_list = np.concatenate([x * np.asarray(rule) for x in shape_funcs])\n        return tuple(map(sympy.diff, shape_list, clist))\n</code></pre>"},{"location":"reference/#tofea.elements.Q4Element","title":"<code>Q4Element</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Element</code></p> <p>Four-node quadrilateral element.</p> Source code in <code>tofea/elements.py</code> <pre><code>class Q4Element(Element):\n    \"\"\"Four-node quadrilateral element.\"\"\"\n\n    @property\n    def symbols(self) -&gt; tuple[sympy.Symbol, ...]:\n        \"\"\"Return the symbols used to define the element.\"\"\"\n\n        return sympy.symbols(\"a b x y\", real=True)\n\n    @property\n    def shape_funcs(self) -&gt; list[sympy.Expr]:\n        \"\"\"Return bilinear shape functions for a four-node element.\"\"\"\n\n        a, b, x, y = self.symbols\n        return [\n            (a - x) * (b - y) / (4 * a * b),\n            (a + x) * (b - y) / (4 * a * b),\n            (a + x) * (b + y) / (4 * a * b),\n            (a - x) * (b + y) / (4 * a * b),\n        ]\n</code></pre>"},{"location":"reference/#tofea.elements.Q4Element.shape_funcs","title":"<code>shape_funcs</code>  <code>property</code>","text":"<p>Return bilinear shape functions for a four-node element.</p>"},{"location":"reference/#tofea.elements.Q4Element.symbols","title":"<code>symbols</code>  <code>property</code>","text":"<p>Return the symbols used to define the element.</p>"},{"location":"reference/#tofea.elements.Q4Element_K","title":"<code>Q4Element_K</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Q4Element</code></p> <p>Plane stress elasticity element.</p> Source code in <code>tofea/elements.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass Q4Element_K(Q4Element):\n    \"\"\"Plane stress elasticity element.\"\"\"\n\n    e: float = 1.0\n    nu: float = 1 / 3\n\n    @cached_property\n    def element(self) -&gt; NDArray:\n        \"\"\"Return the 8x8 stiffness matrix for the element.\n\n        The matrix is computed symbolically and evaluated for the instance\n        parameters.  Small values below ``eps`` are zeroed out to keep the\n        matrix well conditioned.\n\n        Returns\n        -------\n        numpy.ndarray\n            Stiffness matrix of shape ``(8, 8)``.\n\n        Examples\n        --------\n        &gt;&gt;&gt; from tofea.elements import Q4Element_K\n        &gt;&gt;&gt; Q4Element_K().element.shape\n        (8, 8)\n        \"\"\"\n\n        a, b, x, y = self.symbols\n        E, nu = sympy.symbols(\"E nu\", real=True)\n\n        B = sympy.Matrix(\n            [\n                self._b_entries([1, 0], self.shape_funcs, 8 * [x]),\n                self._b_entries([0, 1], self.shape_funcs, 8 * [y]),\n                self._b_entries([1, 1], self.shape_funcs, 4 * [y, x]),\n            ]\n        )\n\n        C = (E / (1 - nu**2)) * sympy.Matrix(\n            [[1, nu, 0], [nu, 1, 0], [0, 0, (1 - nu) / 2]]\n        )\n\n        dK = B.T * C * B\n        K = dK.integrate((x, -a, a), (y, -b, b))\n        K = np.array(\n            K.subs({a: self.dx, b: self.dy, E: self.e, nu: self.nu}),\n            dtype=self.dtype,\n        )\n        K[np.abs(K) &lt; self.eps] = 0\n        return K\n</code></pre>"},{"location":"reference/#tofea.elements.Q4Element_K.element","title":"<code>element</code>  <code>cached</code> <code>property</code>","text":"<p>Return the 8x8 stiffness matrix for the element.</p> <p>The matrix is computed symbolically and evaluated for the instance parameters.  Small values below <code>eps</code> are zeroed out to keep the matrix well conditioned.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Stiffness matrix of shape <code>(8, 8)</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tofea.elements import Q4Element_K\n&gt;&gt;&gt; Q4Element_K().element.shape\n(8, 8)\n</code></pre>"},{"location":"reference/#tofea.elements.Q4Element_T","title":"<code>Q4Element_T</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Q4Element</code></p> <p>Heat conductivity element.</p> Source code in <code>tofea/elements.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass Q4Element_T(Q4Element):\n    \"\"\"Heat conductivity element.\"\"\"\n\n    k: float = 1.0\n\n    @cached_property\n    def element(self) -&gt; NDArray:\n        \"\"\"Return the 4x4 conductivity matrix for the element.\n\n        Returns\n        -------\n        numpy.ndarray\n            Conductivity matrix of shape ``(4, 4)``.\n\n        Examples\n        --------\n        &gt;&gt;&gt; from tofea.elements import Q4Element_T\n        &gt;&gt;&gt; Q4Element_T().element.shape\n        (4, 4)\n        \"\"\"\n\n        a, b, x, y = self.symbols\n        k = sympy.symbols(\"k\", real=True)\n\n        B = sympy.Matrix(\n            [\n                self._b_entries([1], self.shape_funcs, 4 * [x]),\n                self._b_entries([1], self.shape_funcs, 4 * [y]),\n            ]\n        )\n\n        C = sympy.Matrix([[k, 0], [0, k]])\n\n        dK = B.T * C * B\n        K = dK.integrate((x, -a, a), (y, -b, b))\n        K = np.array(K.subs({a: self.dx, b: self.dy, k: self.k}), dtype=self.dtype)\n        K[np.abs(K) &lt; self.eps] = 0\n        return K\n</code></pre>"},{"location":"reference/#tofea.elements.Q4Element_T.element","title":"<code>element</code>  <code>cached</code> <code>property</code>","text":"<p>Return the 4x4 conductivity matrix for the element.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Conductivity matrix of shape <code>(4, 4)</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tofea.elements import Q4Element_T\n&gt;&gt;&gt; Q4Element_T().element.shape\n(4, 4)\n</code></pre>"},{"location":"reference/#tofea.fea2d.FEA2D","title":"<code>FEA2D</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for 2D finite element models.</p> <p>Parameters:</p> Name Type Description Default <code>fixed</code> <code>NDArray[bool_]</code> <p>Boolean mask indicating which degrees of freedom are fixed.</p> required <code>solver</code> <code>str</code> <p>Name of the backend solver to use.</p> <code>DEFAULT_SOLVER</code> <code>dx</code> <code>float</code> <p>Element dimensions in <code>x</code> and <code>y</code> direction.</p> <code>0.5</code> <code>dy</code> <code>float</code> <p>Element dimensions in <code>x</code> and <code>y</code> direction.</p> <code>0.5</code> Notes <p>Subclasses must provide the element matrix and a mapping from element degrees of freedom to system degrees of freedom.</p> Source code in <code>tofea/fea2d.py</code> <pre><code>@dataclass\nclass FEA2D(ABC):\n    \"\"\"Abstract base class for 2D finite element models.\n\n    Parameters\n    ----------\n    fixed\n        Boolean mask indicating which degrees of freedom are fixed.\n    solver\n        Name of the backend solver to use.\n    dx, dy\n        Element dimensions in ``x`` and ``y`` direction.\n\n    Notes\n    -----\n    Subclasses must provide the element matrix and a mapping from element\n    degrees of freedom to system degrees of freedom.\n    \"\"\"\n\n    fixed: NDArray[np.bool_]\n    solver: str = DEFAULT_SOLVER\n    dx: float = 0.5\n    dy: float = 0.5\n\n    @property\n    @abstractmethod\n    def dof_dim(self) -&gt; int: ...\n\n    @property\n    @abstractmethod\n    def element(self) -&gt; NDArray: ...\n\n    @property\n    @abstractmethod\n    def dofmap(self) -&gt; NDArray[np.uint32]: ...\n\n    @property\n    def shape(self) -&gt; tuple[int, int]:\n        \"\"\"Number of elements in :math:`x` and :math:`y` direction.\"\"\"\n\n        nx, ny = self.fixed.shape[:2]\n        return nx - 1, ny - 1\n\n    @cached_property\n    def dofs(self) -&gt; NDArray[np.uint32]:\n        \"\"\"Indices of all degrees of freedom.\"\"\"\n\n        return np.arange(self.fixed.size, dtype=np.uint32)\n\n    @cached_property\n    def fixdofs(self) -&gt; NDArray[np.uint32]:\n        \"\"\"Indices of fixed degrees of freedom.\"\"\"\n\n        return self.dofs[self.fixed.ravel()]\n\n    @cached_property\n    def freedofs(self) -&gt; NDArray[np.uint32]:\n        \"\"\"Indices of free degrees of freedom.\"\"\"\n\n        return self.dofs[~self.fixed.ravel()]\n\n    @cached_property\n    def _solver(self) -&gt; Solver:\n        \"\"\"Backend solver instance.\"\"\"\n\n        return get_solver(self.solver)\n\n    @cached_property\n    def index_map(self) -&gt; NDArray[np.uint32]:\n        \"\"\"Permutation that places free DOFs first.\"\"\"\n\n        indices = np.concatenate([self.freedofs, self.fixdofs])\n        imap = np.zeros_like(self.dofs)\n        imap[indices] = self.dofs\n        return imap\n\n    @cached_property\n    def e2sdofmap(self) -&gt; NDArray[np.uint32]:\n        \"\"\"Map each element to its system DOF indices.\"\"\"\n\n        nx, ny = self.shape\n        x, y = np.unravel_index(np.arange(nx * ny), (nx, ny))\n        idxs = self.dof_dim * (y + x * (ny + 1))\n        return np.add(self.dofmap[None], idxs[:, None].astype(np.uint32))\n\n    @cached_property\n    def keep_indices(\n        self,\n    ) -&gt; tuple[NDArray[np.bool_], NDArray[np.uint32]]:\n        \"\"\"Indices for assembling the global matrix.\"\"\"\n\n        i, j = np.meshgrid(range(len(self.dofmap)), range(len(self.dofmap)))\n        ix = self.e2sdofmap[:, i].ravel()\n        iy = self.e2sdofmap[:, j].ravel()\n        keep = np.isin(ix, self.freedofs) &amp; np.isin(iy, self.freedofs)\n        indices = np.stack([self.index_map[ix][keep], self.index_map[iy][keep]])\n        return keep, indices\n\n    def global_mat(self, x: NDArray) -&gt; tuple[NDArray, NDArray]:\n        \"\"\"Assemble global matrix from element data.\"\"\"\n\n        x = np.reshape(x, (-1, 1, 1)) * self.element[None]\n        x = x.ravel()\n        keep, indices = self.keep_indices\n        return x[keep], indices\n\n    def solve(self, x: NDArray, b: NDArray) -&gt; NDArray:\n        \"\"\"Solve ``K(x) u = b`` for ``u``.\"\"\"\n\n        data, indices = self.global_mat(x)\n        u_nz = solve_coo(data, indices, b.ravel()[self.freedofs], self._solver)\n        u = anp.concatenate([u_nz, np.zeros(len(self.fixdofs))])[self.index_map]\n        return u\n</code></pre>"},{"location":"reference/#tofea.fea2d.FEA2D.dofs","title":"<code>dofs</code>  <code>cached</code> <code>property</code>","text":"<p>Indices of all degrees of freedom.</p>"},{"location":"reference/#tofea.fea2d.FEA2D.e2sdofmap","title":"<code>e2sdofmap</code>  <code>cached</code> <code>property</code>","text":"<p>Map each element to its system DOF indices.</p>"},{"location":"reference/#tofea.fea2d.FEA2D.fixdofs","title":"<code>fixdofs</code>  <code>cached</code> <code>property</code>","text":"<p>Indices of fixed degrees of freedom.</p>"},{"location":"reference/#tofea.fea2d.FEA2D.freedofs","title":"<code>freedofs</code>  <code>cached</code> <code>property</code>","text":"<p>Indices of free degrees of freedom.</p>"},{"location":"reference/#tofea.fea2d.FEA2D.index_map","title":"<code>index_map</code>  <code>cached</code> <code>property</code>","text":"<p>Permutation that places free DOFs first.</p>"},{"location":"reference/#tofea.fea2d.FEA2D.keep_indices","title":"<code>keep_indices</code>  <code>cached</code> <code>property</code>","text":"<p>Indices for assembling the global matrix.</p>"},{"location":"reference/#tofea.fea2d.FEA2D.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Number of elements in :math:<code>x</code> and :math:<code>y</code> direction.</p>"},{"location":"reference/#tofea.fea2d.FEA2D.global_mat","title":"<code>global_mat(x)</code>","text":"<p>Assemble global matrix from element data.</p> Source code in <code>tofea/fea2d.py</code> <pre><code>def global_mat(self, x: NDArray) -&gt; tuple[NDArray, NDArray]:\n    \"\"\"Assemble global matrix from element data.\"\"\"\n\n    x = np.reshape(x, (-1, 1, 1)) * self.element[None]\n    x = x.ravel()\n    keep, indices = self.keep_indices\n    return x[keep], indices\n</code></pre>"},{"location":"reference/#tofea.fea2d.FEA2D.solve","title":"<code>solve(x, b)</code>","text":"<p>Solve <code>K(x) u = b</code> for <code>u</code>.</p> Source code in <code>tofea/fea2d.py</code> <pre><code>def solve(self, x: NDArray, b: NDArray) -&gt; NDArray:\n    \"\"\"Solve ``K(x) u = b`` for ``u``.\"\"\"\n\n    data, indices = self.global_mat(x)\n    u_nz = solve_coo(data, indices, b.ravel()[self.freedofs], self._solver)\n    u = anp.concatenate([u_nz, np.zeros(len(self.fixdofs))])[self.index_map]\n    return u\n</code></pre>"},{"location":"reference/#tofea.fea2d.FEA2D_K","title":"<code>FEA2D_K</code>  <code>dataclass</code>","text":"<p>               Bases: <code>FEA2D</code></p> <p>Finite element model for compliance problems.</p> <p>This model solves small deformation elasticity problems using bilinear quadrilateral elements.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; fixed = np.zeros((2, 2, 2), dtype=bool)\n&gt;&gt;&gt; fem = FEA2D_K(fixed)\n&gt;&gt;&gt; fem.element.shape\n(8, 8)\n</code></pre> Source code in <code>tofea/fea2d.py</code> <pre><code>@dataclass\nclass FEA2D_K(FEA2D):\n    \"\"\"Finite element model for compliance problems.\n\n    This model solves small deformation elasticity problems using bilinear\n    quadrilateral elements.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; fixed = np.zeros((2, 2, 2), dtype=bool)\n    &gt;&gt;&gt; fem = FEA2D_K(fixed)\n    &gt;&gt;&gt; fem.element.shape\n    (8, 8)\n    \"\"\"\n\n    dof_dim: int = 2\n    e: float = 1.0\n    nu: float = 1 / 3\n\n    @cached_property\n    def element(self) -&gt; NDArray:\n        \"\"\"Element stiffness matrix.\"\"\"\n        return Q4Element_K(e=self.e, nu=self.nu, dx=self.dx, dy=self.dy).element\n\n    @cached_property\n    def dofmap(self) -&gt; NDArray[np.uint32]:\n        \"\"\"Mapping of element DOFs to system DOFs.\"\"\"\n        _, nely = self.shape\n        b = np.arange(2 * (nely + 1), 2 * (nely + 1) + 2)\n        a = b + 2\n        return np.r_[2, 3, a, b, 0, 1].astype(np.uint32)\n\n    def displacement(self, x: NDArray, b: NDArray) -&gt; NDArray:\n        \"\"\"Return displacement field for density ``x`` and load ``b``.\"\"\"\n        return self.solve(x, b)\n\n    def compliance(self, x: NDArray, displacement: NDArray) -&gt; NDArray:\n        \"\"\"Compliance objective for ``x`` and ``displacement``.\"\"\"\n        dofmap = np.reshape(self.e2sdofmap.T, (-1, *self.shape))\n        c = anp.einsum(\n            \"ixy,ij,jxy-&gt;xy\", displacement[dofmap], self.element, displacement[dofmap]\n        )\n        return anp.sum(x * c)\n</code></pre>"},{"location":"reference/#tofea.fea2d.FEA2D_K.dofmap","title":"<code>dofmap</code>  <code>cached</code> <code>property</code>","text":"<p>Mapping of element DOFs to system DOFs.</p>"},{"location":"reference/#tofea.fea2d.FEA2D_K.element","title":"<code>element</code>  <code>cached</code> <code>property</code>","text":"<p>Element stiffness matrix.</p>"},{"location":"reference/#tofea.fea2d.FEA2D_K.compliance","title":"<code>compliance(x, displacement)</code>","text":"<p>Compliance objective for <code>x</code> and <code>displacement</code>.</p> Source code in <code>tofea/fea2d.py</code> <pre><code>def compliance(self, x: NDArray, displacement: NDArray) -&gt; NDArray:\n    \"\"\"Compliance objective for ``x`` and ``displacement``.\"\"\"\n    dofmap = np.reshape(self.e2sdofmap.T, (-1, *self.shape))\n    c = anp.einsum(\n        \"ixy,ij,jxy-&gt;xy\", displacement[dofmap], self.element, displacement[dofmap]\n    )\n    return anp.sum(x * c)\n</code></pre>"},{"location":"reference/#tofea.fea2d.FEA2D_K.displacement","title":"<code>displacement(x, b)</code>","text":"<p>Return displacement field for density <code>x</code> and load <code>b</code>.</p> Source code in <code>tofea/fea2d.py</code> <pre><code>def displacement(self, x: NDArray, b: NDArray) -&gt; NDArray:\n    \"\"\"Return displacement field for density ``x`` and load ``b``.\"\"\"\n    return self.solve(x, b)\n</code></pre>"},{"location":"reference/#tofea.fea2d.FEA2D_T","title":"<code>FEA2D_T</code>  <code>dataclass</code>","text":"<p>               Bases: <code>FEA2D</code></p> <p>Finite element model for heat conduction problems.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; fixed = np.zeros((2, 2), dtype=bool)\n&gt;&gt;&gt; fem = FEA2D_T(fixed)\n&gt;&gt;&gt; fem.element.shape\n(4, 4)\n</code></pre> Source code in <code>tofea/fea2d.py</code> <pre><code>@dataclass\nclass FEA2D_T(FEA2D):\n    \"\"\"Finite element model for heat conduction problems.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; fixed = np.zeros((2, 2), dtype=bool)\n    &gt;&gt;&gt; fem = FEA2D_T(fixed)\n    &gt;&gt;&gt; fem.element.shape\n    (4, 4)\n    \"\"\"\n\n    dof_dim: int = 1\n    k: float = 1.0\n\n    @cached_property\n    def element(self) -&gt; NDArray:\n        \"\"\"Element conductivity matrix.\"\"\"\n        return Q4Element_T(k=self.k, dx=self.dx, dy=self.dy).element\n\n    @cached_property\n    def dofmap(self) -&gt; NDArray[np.uint32]:\n        \"\"\"Mapping of element DOFs to system DOFs.\"\"\"\n        _, nely = self.shape\n        return np.r_[1, (nely + 2), (nely + 1), 0].astype(np.uint32)\n\n    def temperature(self, x: NDArray, b: NDArray) -&gt; NDArray:\n        \"\"\"Return temperature field for density ``x`` and load ``b``.\"\"\"\n        return self.solve(x, b)\n</code></pre>"},{"location":"reference/#tofea.fea2d.FEA2D_T.dofmap","title":"<code>dofmap</code>  <code>cached</code> <code>property</code>","text":"<p>Mapping of element DOFs to system DOFs.</p>"},{"location":"reference/#tofea.fea2d.FEA2D_T.element","title":"<code>element</code>  <code>cached</code> <code>property</code>","text":"<p>Element conductivity matrix.</p>"},{"location":"reference/#tofea.fea2d.FEA2D_T.temperature","title":"<code>temperature(x, b)</code>","text":"<p>Return temperature field for density <code>x</code> and load <code>b</code>.</p> Source code in <code>tofea/fea2d.py</code> <pre><code>def temperature(self, x: NDArray, b: NDArray) -&gt; NDArray:\n    \"\"\"Return temperature field for density ``x`` and load ``b``.\"\"\"\n    return self.solve(x, b)\n</code></pre>"},{"location":"reference/#tofea.primitives.solve_coo","title":"<code>solve_coo(entries, indices, rhs, solver)</code>","text":"<p>Solve a sparse linear system in COO format.</p> <p>Parameters:</p> Name Type Description Default <code>entries</code> <code>array - like</code> <p>Non-zero matrix entries.</p> required <code>indices</code> <code>tuple[array - like, array - like]</code> <p>Row and column indices for <code>entries</code>.</p> required <code>rhs</code> <code>array - like</code> <p>Right-hand side vector.</p> required <code>solver</code> <code>Solver</code> <p>Factorization backend used to solve the system.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Solution vector.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from scipy.sparse import coo_matrix\n&gt;&gt;&gt; from tofea.primitives import solve_coo\n&gt;&gt;&gt; from tofea.solvers import get_solver\n&gt;&gt;&gt; m = coo_matrix([[4, 1], [1, 3]])\n&gt;&gt;&gt; b = np.array([1, 2])\n&gt;&gt;&gt; solve_coo(m.data, (m.row, m.col), b, get_solver(\"SuperLU\"))\narray([0.09090909, 0.63636364])\n</code></pre> Source code in <code>tofea/primitives.py</code> <pre><code>@primitive\ndef solve_coo(\n    entries: NDArray,\n    indices: tuple[NDArray[np.int_], NDArray[np.int_]],\n    rhs: NDArray,\n    solver: Solver,\n) -&gt; NDArray:\n    \"\"\"Solve a sparse linear system in COO format.\n\n    Parameters\n    ----------\n    entries : array-like\n        Non-zero matrix entries.\n    indices : tuple[array-like, array-like]\n        Row and column indices for ``entries``.\n    rhs : array-like\n        Right-hand side vector.\n    solver : tofea.solvers.Solver\n        Factorization backend used to solve the system.\n\n    Returns\n    -------\n    numpy.ndarray\n        Solution vector.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from scipy.sparse import coo_matrix\n    &gt;&gt;&gt; from tofea.primitives import solve_coo\n    &gt;&gt;&gt; from tofea.solvers import get_solver\n    &gt;&gt;&gt; m = coo_matrix([[4, 1], [1, 3]])\n    &gt;&gt;&gt; b = np.array([1, 2])\n    &gt;&gt;&gt; solve_coo(m.data, (m.row, m.col), b, get_solver(\"SuperLU\"))\n    array([0.09090909, 0.63636364])\n    \"\"\"\n\n    a = coo_matrix((entries, indices)).tocsc()\n    solver.clear()\n    solver.factor(a)\n    return solver.solve(rhs)\n</code></pre>"},{"location":"reference/#tofea.primitives.solve_coo_b_jvp","title":"<code>solve_coo_b_jvp(g, x, entries, indices, rhs, solver)</code>","text":"<p>Forward-mode derivative of :func:<code>solve_coo</code> with respect to <code>rhs</code>.</p> Source code in <code>tofea/primitives.py</code> <pre><code>def solve_coo_b_jvp(\n    g: NDArray,\n    x: NDArray,  # noqa: ARG001\n    entries: NDArray,  # noqa: ARG001\n    indices: tuple[NDArray[np.int_], NDArray[np.int_]],  # noqa: ARG001\n    rhs: NDArray,  # noqa: ARG001\n    solver: Solver,\n) -&gt; NDArray:\n    \"\"\"Forward-mode derivative of :func:`solve_coo` with respect to ``rhs``.\"\"\"\n\n    return solver.solve(g)\n</code></pre>"},{"location":"reference/#tofea.primitives.solve_coo_b_vjp","title":"<code>solve_coo_b_vjp(ans, entries, indices, rhs, solver)</code>","text":"<p>Reverse-mode derivative of :func:<code>solve_coo</code> for <code>rhs</code>.</p> Source code in <code>tofea/primitives.py</code> <pre><code>def solve_coo_b_vjp(\n    ans: NDArray,  # noqa: ARG001\n    entries: NDArray,  # noqa: ARG001\n    indices: tuple[NDArray[np.int_], NDArray[np.int_]],  # noqa: ARG001\n    rhs: NDArray,  # noqa: ARG001\n    solver: Solver,\n) -&gt; Callable[[NDArray], NDArray]:\n    \"\"\"Reverse-mode derivative of :func:`solve_coo` for ``rhs``.\"\"\"\n\n    def vjp(g: NDArray) -&gt; NDArray:\n        return solver.solve(g, transpose=True)\n\n    return vjp\n</code></pre>"},{"location":"reference/#tofea.primitives.solve_coo_entries_jvp","title":"<code>solve_coo_entries_jvp(g, x, entries, indices, rhs, solver)</code>","text":"<p>Forward-mode derivative of :func:<code>solve_coo</code> with respect to <code>entries</code>.</p> Source code in <code>tofea/primitives.py</code> <pre><code>def solve_coo_entries_jvp(\n    g: NDArray,\n    x: NDArray,\n    entries: NDArray,  # noqa: ARG001\n    indices: tuple[NDArray[np.int_], NDArray[np.int_]],\n    rhs: NDArray,  # noqa: ARG001\n    solver: Solver,\n) -&gt; NDArray:\n    \"\"\"Forward-mode derivative of :func:`solve_coo` with respect to ``entries``.\"\"\"\n\n    a = coo_matrix((g, indices)).tocsc()\n    return solver.solve(-(a @ x))\n</code></pre>"},{"location":"reference/#tofea.primitives.solve_coo_entries_vjp","title":"<code>solve_coo_entries_vjp(ans, entries, indices, rhs, solver)</code>","text":"<p>Reverse-mode derivative of :func:<code>solve_coo</code> for <code>entries</code>.</p> Source code in <code>tofea/primitives.py</code> <pre><code>def solve_coo_entries_vjp(\n    ans: NDArray,\n    entries: NDArray,  # noqa: ARG001\n    indices: tuple[NDArray[np.int_], NDArray[np.int_]],\n    rhs: NDArray,  # noqa: ARG001\n    solver: Solver,\n) -&gt; Callable[[NDArray], NDArray]:\n    \"\"\"Reverse-mode derivative of :func:`solve_coo` for ``entries``.\"\"\"\n\n    def vjp(g: NDArray) -&gt; NDArray:\n        x = solver.solve(g, transpose=True)\n        i, j = indices\n        return -x[i] * ans[j]\n\n    return vjp\n</code></pre>"},{"location":"reference/#tofea.solvers.Solver","title":"<code>Solver</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract interface for linear solvers.</p> Source code in <code>tofea/solvers.py</code> <pre><code>class Solver(ABC):\n    \"\"\"Abstract interface for linear solvers.\"\"\"\n\n    @abstractmethod\n    def factor(self, m: csc_matrix) -&gt; None: ...\n\n    @abstractmethod\n    def solve(self, rhs: NDArray, transpose: bool = False) -&gt; NDArray: ...\n\n    @abstractmethod\n    def clear(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/#tofea.solvers.SuperLU","title":"<code>SuperLU</code>","text":"<p>               Bases: <code>Solver</code></p> <p><code>scipy.sparse.linalg.splu</code> wrapper.</p> Source code in <code>tofea/solvers.py</code> <pre><code>class SuperLU(Solver):\n    \"\"\"`scipy.sparse.linalg.splu` wrapper.\"\"\"\n\n    def __init__(\n        self, **options: float | int | bool | str | Mapping[str, bool]\n    ) -&gt; None:\n        \"\"\"Create a new ``SuperLU`` solver instance.\"\"\"\n        # store solver-specific context on the instance to avoid cross-talk\n        self._ctx: dict[str, Any] = {\"splu\": partial(splu, **options)}\n\n    def factor(self, m: csc_matrix) -&gt; None:\n        \"\"\"Compute the factorization of ``m``.\"\"\"\n        self._ctx[\"factorization\"] = self._ctx[\"splu\"](m)\n\n    def solve(self, rhs: NDArray, transpose: bool = False) -&gt; NDArray:\n        \"\"\"Solve the linear system.\"\"\"\n        return self._ctx[\"factorization\"].solve(rhs, trans=\"T\" if transpose else \"N\")\n\n    def clear(self) -&gt; None:\n        \"\"\"Remove cached factorization.\"\"\"\n        self._ctx.pop(\"factorization\", None)\n</code></pre>"},{"location":"reference/#tofea.solvers.SuperLU.__init__","title":"<code>__init__(**options)</code>","text":"<p>Create a new <code>SuperLU</code> solver instance.</p> Source code in <code>tofea/solvers.py</code> <pre><code>def __init__(\n    self, **options: float | int | bool | str | Mapping[str, bool]\n) -&gt; None:\n    \"\"\"Create a new ``SuperLU`` solver instance.\"\"\"\n    # store solver-specific context on the instance to avoid cross-talk\n    self._ctx: dict[str, Any] = {\"splu\": partial(splu, **options)}\n</code></pre>"},{"location":"reference/#tofea.solvers.SuperLU.clear","title":"<code>clear()</code>","text":"<p>Remove cached factorization.</p> Source code in <code>tofea/solvers.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Remove cached factorization.\"\"\"\n    self._ctx.pop(\"factorization\", None)\n</code></pre>"},{"location":"reference/#tofea.solvers.SuperLU.factor","title":"<code>factor(m)</code>","text":"<p>Compute the factorization of <code>m</code>.</p> Source code in <code>tofea/solvers.py</code> <pre><code>def factor(self, m: csc_matrix) -&gt; None:\n    \"\"\"Compute the factorization of ``m``.\"\"\"\n    self._ctx[\"factorization\"] = self._ctx[\"splu\"](m)\n</code></pre>"},{"location":"reference/#tofea.solvers.SuperLU.solve","title":"<code>solve(rhs, transpose=False)</code>","text":"<p>Solve the linear system.</p> Source code in <code>tofea/solvers.py</code> <pre><code>def solve(self, rhs: NDArray, transpose: bool = False) -&gt; NDArray:\n    \"\"\"Solve the linear system.\"\"\"\n    return self._ctx[\"factorization\"].solve(rhs, trans=\"T\" if transpose else \"N\")\n</code></pre>"},{"location":"reference/#tofea.solvers.get_solver","title":"<code>get_solver(solver)</code>","text":"<p>Return a solver instance by name.</p> <p>Parameters:</p> Name Type Description Default <code>solver</code> <code>str</code> <p>Name of the solver implementation. Currently only <code>\"SuperLU\"</code> is available.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tofea.solvers import get_solver, Solver\n&gt;&gt;&gt; s = get_solver(\"SuperLU\")\n&gt;&gt;&gt; isinstance(s, Solver)\nTrue\n</code></pre> Source code in <code>tofea/solvers.py</code> <pre><code>def get_solver(solver: str) -&gt; Solver:\n    \"\"\"Return a solver instance by name.\n\n    Parameters\n    ----------\n    solver\n        Name of the solver implementation. Currently only ``\"SuperLU\"`` is\n        available.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from tofea.solvers import get_solver, Solver\n    &gt;&gt;&gt; s = get_solver(\"SuperLU\")\n    &gt;&gt;&gt; isinstance(s, Solver)\n    True\n    \"\"\"\n    match solver:\n        case \"SuperLU\":\n            return SuperLU(\n                diag_pivot_thresh=0.1,\n                permc_spec=\"MMD_AT_PLUS_A\",\n                options={\"SymmetricMode\": True},\n            )\n        case _:\n            raise ValueError(f\"Invalid solver: {solver}\")\n</code></pre>"}]}